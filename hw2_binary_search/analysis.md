# Анализ сложности алгоритма бинарного поиска

## Описание алгоритма

Бинарный поиск работает только с **отсортированными** списками. На каждом шаге он делит оставшуюся область поиска пополам: сравнивает искомый элемент со средним и отбрасывает ту половину, в которой элемента заведомо нет. Это позволяет находить элемент за логарифмическое число шагов.

## Временна́я сложность (Time Complexity)

| Случай | Сложность | Пояснение |
|--------|-----------|-----------|
| Лучший (Best) | **O(1)** | Искомый элемент оказался ровно посередине |
| Средний (Average) | **O(log n)** | В среднем нужно log₂(n) делений пополам |
| Худший (Worst) | **O(log n)** | Элемент в конце или отсутствует |

**Вывод:** При увеличении списка в 1000 раз количество шагов растёт всего на ~10 (log₂ 1000 ≈ 10). Это радикально лучше, чем O(n) у линейного поиска.

## Пространственная сложность (Space Complexity)

**O(1)** — алгоритм использует только три вспомогательные переменные: `left`, `right`, `mid`. Объём памяти не зависит от размера списка.

## Сравнение с линейным поиском

| Алгоритм | Временная сложность | Требует сортировки? |
|----------|---------------------|---------------------|
| Линейный поиск | O(n) | Нет |
| Бинарный поиск | O(log n) | Да |

## Выводы

1. **Скорость.** Бинарный поиск значительно быстрее линейного на больших данных: для списка из 1 000 000 элементов линейный делает до 1 000 000 сравнений, бинарный — не более 20.
2. **Ограничение.** Список обязательно должен быть отсортирован заранее. Если данные постоянно меняются, стоимость поддержания сортировки может нивелировать выигрыш.
3. **Применимость.** Бинарный поиск — оптимальный выбор для статических или редко изменяемых больших отсортированных коллекций.
