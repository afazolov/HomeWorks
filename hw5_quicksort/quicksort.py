"""
K3 — Быстрая сортировка (QuickSort)
--------------------------------------
Принцип (стратегия "Разделяй и властвуй"):
  1. Выбрать опорный элемент (pivot)
  2. Разделить список на три части:
       — элементы меньше pivot
       — элементы равные pivot
       — элементы больше pivot
  3. Рекурсивно отсортировать левую и правую части
  4. Объединить: [меньше] + [равные] + [больше]

Временная сложность:
  Лучший/Средний случай — O(n log n)  (pivot делит список примерно пополам)
  Худший случай          — O(n²)       (уже отсортированный список, pivot = min/max)

Пространственная сложность: O(log n) — глубина стека вызовов
"""


def quicksort(lst: list) -> list:
    """
    Быстрая сортировка.

    Принимает список, возвращает новый отсортированный список.
    Исходный список не изменяется.
    """
    # Базовый случай: список из 0 или 1 элемента уже отсортирован
    if len(lst) <= 1:
        return lst

    # Выбираем опорный элемент — средний элемент списка
    # (лучше чем первый/последний: снижает вероятность худшего случая)
    pivot = lst[len(lst) // 2]

    # Разбиваем список на три части
    меньше  = [x for x in lst if x < pivot]   # всё что меньше опорного
    равные  = [x for x in lst if x == pivot]  # все вхождения опорного
    больше  = [x for x in lst if x > pivot]   # всё что больше опорного

    # Рекурсивно сортируем части и объединяем
    return quicksort(меньше) + равные + quicksort(больше)


# ---------------------------------------------------------------------------
# Демонстрация
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    примеры = [
        [3, 6, 8, 10, 1, 2, 1],
        [64, 34, 25, 12, 22, 11, 90],
        [],
        [42],
        [5, 5, 5, 5],
        [9, 8, 7, 6, 5, 4, 3, 2, 1],   # Обратный порядок
    ]

    for lst in примеры:
        sorted_lst = quicksort(lst)
        print(f"quicksort({lst})")
        print(f"         → {sorted_lst}\n")
