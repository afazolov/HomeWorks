"""
K1 + K2 — Класс Queue и симуляция обработки задач
---------------------------------------------------
Очередь — структура данных по принципу FIFO (First In, First Out):
первый добавленный элемент извлекается первым.

Аналогия: очередь в магазине — кто пришёл первым, того и обслужат первым.

Реализованные операции:
  enqueue(item) — добавить элемент в конец очереди
  dequeue()     — извлечь и вернуть первый элемент
  peek()        — посмотреть на первый элемент, не извлекая
  is_empty()    — проверить, пуста ли очередь
  size()        — количество элементов в очереди
"""

from collections import deque


class Queue:
    """
    Очередь на основе collections.deque.

    deque обеспечивает O(1) для добавления в конец и удаления из начала,
    в отличие от обычного списка (list.pop(0) работает за O(n)).
    """

    def __init__(self):
        # deque — двусторонняя очередь из стандартной библиотеки
        self._data = deque()

    def enqueue(self, item) -> None:
        """
        Добавляет элемент item в конец очереди.
        Сложность: O(1)
        """
        self._data.append(item)   # добавляем в правый конец — это "хвост"

    def dequeue(self):
        """
        Извлекает и возвращает первый элемент очереди.
        Сложность: O(1)

        Вызывает IndexError, если очередь пуста.
        """
        if self.is_empty():
            raise IndexError("dequeue из пустой очереди")
        return self._data.popleft()  # снимаем с левого конца — это "голова"

    def peek(self):
        """
        Возвращает первый элемент очереди, НЕ удаляя его.
        Сложность: O(1)

        Вызывает IndexError, если очередь пуста.
        """
        if self.is_empty():
            raise IndexError("peek на пустой очереди")
        return self._data[0]  # первый элемент = голова очереди

    def is_empty(self) -> bool:
        """
        Возвращает True, если очередь пуста.
        Сложность: O(1)
        """
        return len(self._data) == 0

    def size(self) -> int:
        """
        Возвращает количество элементов в очереди.
        Сложность: O(1)
        """
        return len(self._data)

    def __repr__(self) -> str:
        """Текстовое представление: голова слева, хвост справа."""
        return f"Queue(голова → {list(self._data)} → хвост)"


# ---------------------------------------------------------------------------
# K2 — Симуляция обработки задач через очередь
# ---------------------------------------------------------------------------
def simulate_task_queue(tasks: list[dict]) -> None:
    """
    Симулирует обработку задач в очереди по принципу FIFO.

    Каждая задача — словарь с полями:
        name     — название задачи
        duration — время выполнения в секундах

    Выводит момент завершения каждой задачи.
    """
    queue = Queue()

    # Добавляем все задачи в очередь
    for task in tasks:
        queue.enqueue(task)

    print("=" * 55)
    print("Симуляция обработки задач (FIFO — очередь)")
    print("=" * 55)
    print(f"Задач в очереди: {queue.size()}\n")
    print(f"{'Задача':<20} | {'Длит. (сек)':>12} | {'Завершится в (сек)':>20}")
    print("-" * 58)

    current_time = 0  # Текущее время симуляции (в секундах)

    while not queue.is_empty():
        task = queue.dequeue()          # Берём следующую задачу
        current_time += task["duration"]  # Прибавляем время выполнения
        print(f"{task['name']:<20} | {task['duration']:>12} | {current_time:>20}")

    print("-" * 58)
    print(f"Все задачи завершены. Общее время: {current_time} сек.\n")


# ---------------------------------------------------------------------------
# Демонстрация
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    # K1 — Демонстрация операций очереди
    print("=" * 45)
    print("K1: Демонстрация операций класса Queue")
    print("=" * 45)

    q = Queue()
    print(f"Пустая? {q.is_empty()}")     # True

    q.enqueue("Задача A")
    q.enqueue("Задача B")
    q.enqueue("Задача C")
    print(q)                             # Queue(голова → [...] → хвост)
    print(f"Размер: {q.size()}")         # 3
    print(f"Первый (peek): {q.peek()}")  # Задача A

    print(f"Снято: {q.dequeue()}")       # Задача A  (первым вошёл — первым вышел)
    print(f"Снято: {q.dequeue()}")       # Задача B
    print(q)
    print()

    # K2 — Симуляция очереди задач
    задачи = [
        {"name": "Резервное копирование", "duration": 10},
        {"name": "Отправка email",        "duration":  3},
        {"name": "Генерация отчёта",      "duration":  7},
        {"name": "Обновление кэша",       "duration":  2},
        {"name": "Очистка логов",         "duration":  5},
    ]
    simulate_task_queue(задачи)
